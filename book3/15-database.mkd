Usando Banco de dados e SQL
=======================

O que é um banco de dados?
-------------------

\index{banco de dados}

Um *banco de dados* é um arquivo que é organizado para armazenar
dados. A maioria dos bancos de dados são organizados como um dicionário no sentido de
que mapeiam das chaves aos valores. A maior diferença é que o
banco de dados está no disco (ou em outro armazenamento permanente), portanto persiste
depois do programa terminar. Como um banco de dados é guardado em armazenamento permanente,
ele pode armazenar muito mais dados que um dicionário, o qual é limitado ao tamanho
da memória no computador.


\index{banco de dados!índices}

Como um dicionário, o software de banco de dados é projetado para manter a inserção
e o acesso aos dados muito rápidos, mesmo para grandes quantidades.
O software de banco de dados mantém seu desempenho construindo
*índices* na medida em que dados são adicionados ao banco de dados para permitir
que o computador pule rapidamente para uma entrada específica.

Existem vários sistemas de banco de dados que são usados para uma larga
quantidade de propósitos incluindo: Oracle, MySQL, Microsoft SQL Server,
PostgreSQL, e SQLite. Focamos em SQLite nesse livro porque é um
banco de dados muito comum e já está incorporado em Python. SQLite é
desenvolvido para ser *incorporado* em outros aplicativos para prover
suporte ao banco de dados dentro do aplicativo. Por exemplo, o navegador Firefox
também usa o banco de dados SQLite internamente assim como muitos outros produtos.

<http://sqlite.org/>

SQLite é adequado para alguns dos problemas de manipulação de dados que
vemos na Informática como o aplicativo spidering do twitter que
descrevemos nesse capítulo. 

Conceitos de Banco de dados
-----------------

Quando você olha pela primeira vez para um banco de dados, ele parece com uma tabela
com várias folhas. As estruturas primárias de dados em um banco de dados são:
*tabelas*, *linhas*, e 
*colunas*.

![Relational Databases](height=2.0in@../images/relational)

Nas descrições técnicas dos bancos de dados relacionais, os conceitos de tabela, de
linha, e de coluna são formalmente chamados de
*relação*, *tupla*, e *atributo*, respectivamente. Nós usaremos os termos
menos formais nesse capítulo.

Navegador de Banco de Dados para SQLite
---------------------------

Já que esse capítulo focará em usar Python para trabalhar com dados em arquivos de bancos de dados SQLite, várias operações podem ser feitas de maneira mais conveniente, usando um software chamado *Database Browser for SQLite* (*Navegador de Banco de Dados para SQLite*), o qual está disponibilizado gratuitamente em:

<http://sqlitebrowser.org/>

Usando o navegador você pode facilmente criar tabelas, inserir dados, editar dados,
ou executar consultas SQL simples nos dados do banco de dados.

Em certo sentido, o navegador de banco de dados é similar a um editor de texto
quando trabalhando com arquivos de textos. Quando se quer fazer mais de uma ou algumas
poucas operações em um arquivo de texto, basta apenas abrí-lo em um editor
e fazer as mudanças que deseja. Quando se tem muitas mudanças que necessárias a fazer em
um arquivo de texto, geralmente se escreve um programa simples em Python. Você encontrará
o mesmo padrão quando trabalhar com banco de dados. Você fará operações simples
no gerenciador do banco de dados e operações mais complexas serão feitas
mais convenientemente em Python.

Criando uma tabela de banco de dados
-------------------------

Bancos de dados requerem estrutura mais definida do que listas ou bibliotecas Python.^[SQLite de fato permite certa flexibilidade no tipo de dado armazenado em uma coluna, mas vamos manter nossos tipos de dados restritos nesse capítulo para que os conceitos se apliquem igualmente para outros sistemas de bancos de dados, a exemplo do MySQL.].

Quando criamos uma *tabela* de banco de dados, devemos informar antecipadamente os nomes de cada uma das *colunas* da tabela e o tipo de dados que estamos planejando armazenar em cada *coluna*. Quando o software de banco de dados conhece o tipo de dado em cada coluna, ele pode escolher a maneira mais eficiente de armazenar e de procurar os dados com base no seu tipo.

Você pode observar os vários tipos de dados suportados pelo SQLite na seguinte URL:

<http://www.sqlite.org/datatypes.html>

A definição da estrutura dos seus dados antecipadamente pode parecer inconveniente no início, mas a recompensa é o acesso rápido aos seus dados, mesmo quando o banco de dados contém uma grande quantidade deles.

O código para criar um arquivo de banco de dados e uma tabela denominada `Tracks` com duas colunas no banco de dados é o seguinte:

\index{sqlite3 module}
\index{module!sqlite3}

\VerbatimInput{../code3/db1.py}

\index{função connect}
\index{função!connect}
\index{função cursor}
\index{função!cursor}

A operação de `connect` faz uma "conexão" com o banco de dados armazenado no arquivo `music.sqlite` no diretório atual. Se o arquivo não existir, ele será criado. O motivo pelo qual isso é chamado de "conexão" é que, às vezes, o banco de dados é armazenado em um "servidor de banco de dados" separado do servidor no qual estamos executando nosso aplicativo. Em nossos exemplos simples, o banco de dados será apenas um arquivo local no mesmo diretório que o código Python que estamos executando.

Um *cursor* é como um identificador de arquivo que podemos usar para executar operações nos dados armazenados no banco de dados. Chamar `cursor()` é muito semelhante conceitualmente a chamar `open()` ao lidar com arquivos de texto.

![A Database Cursor](height=2.0in@../images/cursor)

Uma vez que temos o cursor, podemos começar a executar comandos no conteúdo do banco de dados usando o método `execute()`.

Os comandos do banco de dados são expressos em um idioma especial que foi padronizado em muitos fornecedores diferentes para nos permitir aprender um único idioma de banco de dados. Essa linguagem é chamada de *Structured Query Language* (*Linguagem de Consulta Estruturada*) ou *SQL*, para abreviar.

<http://en.wikipedia.org/wiki/SQL>

Em nosso exemplo, estamos executando dois comandos SQL em nosso banco de dados. Como convenção, mostraremos as palavras-chave SQL em maiúsculas e as partes do comando que estamos adicionando (como os nomes de tabela e de coluna) serão mostradas em minúsculas.

O primeiro comando SQL remove a tabela `Tracks` do banco de dados, se existir. Esse padrão é simplesmente para permitir a execução do mesmo programa para criar a tabela `Tracks` repetidamente, sem causar erros. Observe que o comando `DROP TABLE` exclui a tabela e todo o seu conteúdo do banco de dados (ou seja, não há "desfazer").

~~~~ {.python}
cur.execute('DROP TABLE IF EXISTS Tracks ')
~~~~

O segundo comando cria uma tabela chamada `Tracks` com uma coluna de texto chamada `title` e uma coluna inteira chamada `plays`.

~~~~ {.python}
cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
~~~~

Agora que criamos uma tabela chamada `Tracks`, podemos colocar alguns dados nessa tabela usando a operação SQL `INSERT`. Novamente, começamos fazendo uma conexão com o banco de dados e obtendo o `cursor`. Podemos então executar comandos SQL usando o cursor.

O comando SQL `INSERT` indica qual tabela estamos usando e, em seguida, define uma nova linha listando os campos que queremos incluir `(title, plays)` seguidos pelos `VALUES` que queremos que sejam colocados na nova linha. Especificamos os valores como pontos de interrogação `(?, ?)` Para indicar que os valores reais são passados como uma tupla `( 'My Way', 15 )` como o segundo parâmetro para a chamada `execute()`.

\VerbatimInput{../code3/db2.py}

Primeiro, nós utilizamos `INSERT` para duas linhas em nossa tabela e usamos `commit()` para forçar os dados a serem gravados no arquivo de banco de dados.

![Rows in a Table](height=1.5in@../images/tracks)

Em seguida, usamos o comando `SELECT` para recuperar as linhas que acabamos de inserir da tabela. No comando `SELECT`, indicamos de quais colunas gostaríamos `(title, plays)` e de qual tabela queremos recuperar os dados. Depois de executar a instrução `SELECT`, o cursor é algo pelo qual podemos percorrer uma instrução `for`. Por questões de eficiência, o cursor não lê todos os dados do banco de dados quando executamos a instrução `SELECT`. Em vez disso, os dados são lidos sob demanda, conforme percorremos as linhas na instrução `for`.

A saída do programa é a seguinte:

~~~~
Tracks:
('Thunderstruck', 20)
('My Way', 15)
~~~~

\index{Unicode}

Nosso loop `for` encontra duas linhas, e cada linha é uma tupla Python com o primeiro valor como o `title` e o segundo valor como o número de `plays`.

*Nota: Você pode ver cadeias começando com `u'` em outros livros ou na Internet. Essa foi uma indicação no Python 2 de que as strings são strings Unicode capazes de armazenar conjuntos de caracteres não latinos. No Python 3, todas as strings são unicode por padrão.*

No final do programa, executamos um comando SQL para `DELETE` as linhas que acabamos de criar, para que possamos executar o programa repetidamente. O comando `DELETE` mostra o uso de uma cláusula `WHERE` que nos permite expressar um critério de seleção para que possamos solicitar ao banco de dados que aplique o comando apenas às linhas que correspondem ao critério. Nesse exemplo, o critério se aplica a todas as linhas, de modo que esvaziamos a tabela para que possamos executar o programa repetidamente. Depois que o `DELETE` é executado, também chamamos `commit()` para forçar os dados a serem removidos do banco de dados.

Resumo da Structured Query Language (Linguagem de Consulta Estruturada)
---------------------------------

Até o momento, usamos a Structured Query Language em nossos exemplos de Python e cobrimos muitos dos princípios básicos dos comandos SQL. Nesta seção, examinamos a linguagem SQL em particular e fornecemos uma visão geral da sintaxe SQL.

Como existem muitos fornecedores diferentes de banco de dados, a Structured Query Language (SQL) foi padronizada para que pudéssemos nos comunicar de maneira portátil aos sistemas de banco de dados de vários fornecedores.

Um banco de dados relacional é composto de tabelas, linhas e colunas. As colunas geralmente têm um tipo como texto, dados numéricos ou de data. Quando criamos uma tabela, indicamos os nomes e os tipos das colunas:

~~~~ {.sql}
CREATE TABLE Tracks (title TEXT, plays INTEGER)
~~~~

Para inserir uma linha em uma tabela, usamos o comando SQL `INSERT`:


~~~~ {.sql}
INSERT INTO Tracks (title, plays) VALUES ('My Way', 15)
~~~~

A instrução `INSERT` especifica o nome da tabela, uma lista dos campos/colunas que você deseja definir na nova linha e, em seguida, a palavra-chave `VALUES` e uma lista dos valores correspondentes para cada um dos campos.


O comando SQL `SELECT` é usado para recuperar linhas e colunas de um banco de dados. A instrução `SELECT` permite especificar quais colunas você gostaria de recuperar, bem como uma cláusula `WHERE` para selecionar quais linhas você gostaria de ver. Ele também permite que uma cláusula `ORDER BY` opcional controle a classificação das linhas retornadas.


~~~~ {.sql}
SELECT * FROM Tracks WHERE title = 'My Way'
~~~~

Usar `*` indica que você deseja que o banco de dados retorne todas as colunas para cada linha que corresponda à cláusula `WHERE`.

Observe que, diferentemente do Python, em uma cláusula SQL `WHERE` usamos um único sinal de igual para indicar um teste de igualdade em vez de um duplo sinal de igual. Outras operações lógicas permitidas em uma cláusula WHERE incluem `<`, `>`, `<=`, `>=`, `!=`, Além de `AND` e `OR` e parênteses para construir suas expressões lógicas.

Você pode solicitar que as linhas retornadas sejam classificadas por um dos campos da seguinte maneira:

~~~~ {.sql}
SELECT title,plays FROM Tracks ORDER BY title
~~~~

Para remover uma linha, você precisa de uma cláusula `WHERE` em uma instrução SQL `DELETE`. A cláusula `WHERE` determina quais linhas devem ser excluídas:

~~~~ {.sql}
DELETE FROM Tracks WHERE title = 'My Way'
~~~~

É possível `UPDATE` uma coluna ou colunas dentro de uma ou mais linhas em uma tabela usando a instrução SQL `UPDATE` da seguinte maneira:

~~~~ {.sql}
UPDATE Tracks SET plays = 16 WHERE title = 'My Way'
~~~~

A instrução `UPDATE` especifica uma tabela e, em seguida, uma lista de campos e valores a serem alterados após a palavra-chave `SET` e, em seguida, uma cláusula `WHERE` opcional para selecionar as linhas que devem ser atualizadas. Uma única instrução `UPDATE` poderá alterar todas as linhas que correspondem à cláusula `WHERE`. Se uma cláusula `WHERE` não for especificada, ela executará o `UPDATE` em todas as linhas da tabela

Esses quatro comandos SQL básicos (INSERT, SELECT, UPDATE e DELETE) permitem as quatro operações básicas necessárias para criar e manter dados.


Rastreando contas no Twitter usando banco de dados
----------------------------------

Nesta seção, vamos criar um simples programa de rastreamento que 
irá vasculhar contas no Twitter e irá criar um banco de dados dessas contas. 
*Nota: Tenha muito cuidado quando executar esse programa. Você não 
deseja puxar muitas informações ou não quer que seu programa rode 
por muito tempo. Caso contrário, sua conta pode ser desativada.*

Um dos maiores problemas de qualquer programa de rastreamento é a 
necessidade de ser parado e reiniciado muitas vezes e você não quer 
perder dados obtidos até o momento. Você não quer que sua obtenção 
de dados seja reiniciada toda vez que o programa for reiniciado, 
ou seja, você quer que seu programa continue a pegar dados 
de onde ele parou.


Nós vamos começar coletando informações sobre os amigos e seus 
status de uma determinada pessoa no Twitter, percorrendo a lista
de amigos e adicionando cada um dos amigos ao nosso banco de dados 
que será recuperado no futuro. Depois que vasculharmos a lista dessa pessoa, 
vamos checar nosso banco de dados e iremos acessar um dos amigos 
dessa lista. Nós vamos fazer isso repetidamente, acessando pessoas 
ainda "não visitadas", obtendo suas listas de amigos, e adicionando 
amigos que nós ainda não vimos na nossa lista para uma futura visita.

Também iremos verificar quantas vezes vimos um amigo em particular 
no nosso banco de dados para ter uma ideia da "popularidade" dele.

Armazenando nossa lista de contas conhecidas, se uma 
conta ja foi rastreada ou não e o quão popular uma conta é no 
nosso banco de dados no nosso disco, podemos parar e reiniciar 
nosso programa quantas vezes quisermos.

O programa é um pouco complexo. É baseado no código do 
exercício anteriormente exposto nesse livro que usa a API do Twitter.

Aqui está o código-fonte para nossa aplicação de 
rastreamento sobre o Twitter:

\VerbatimInput{../code3/twspider.py}

Nosso banco de dados é armazenado no arquivo `spider.sqlite3` e tem 
uma tabela chamada `Twitter`. Cada linha na tabela `Twitter` tem 
uma coluna para o nome da conta, caso nós tenhamos obtido os amigos 
dessa conta e quantas vezes essa conta foi "adicionada".

No laço principal do nosso programa, nós solicitamos do nosso 
usuário o nome da conta do Twitter ou que ele digite "sair" para 
sair do programa. Se o usuário entrar com uma conta Twitter, 
nós iremos rastrear a lista de amigos e os status desse usuário e 
iremos adicionar cada amigo no nosso banco de dados, caso ainda não 
esteja nele. Se o amigo já estiver na lista, nós adicionamos 
1 para o campo `amigos` na linha do banco de dados.

Se o usuário pressionar a tecla "enter", nós olhamos o banco 
de dados para a próxima conta do Twitter que nós ainda não 
acessamos, obtendo os amigos e os status dessa conta e adicionando-os 
ao banco de dados ou atualizando-os e aumentando o contador `amigos`.

Depois que obtivermos a lista de amigos e seus status, vamos 
percorrer todos os itens do `usuário` no retorno JSON e recuperaremos 
o `screen_name` para cada usuário. Depois usaremos a declaração `SELECT` 
para ver se já armazenamos um `screen_name` em particular no nosso banco 
de dados, recuperando a conta amigo (`amigos`) se a gravação existir.

~~~~ {.python}
contadornovo = 0
contadorantigo = 0
for u in js['users'] :
    friend = u['screen_name']
    print(amigo)
    cur.execute('SELECT amigos FROM Twitter WHERE nome = ? LIMIT 1',
        (friend, ) )
    try:
        contador = cur.fetchone()[0]
        cur.execute('UPDATE Twitter SET amigos = ? WHERE nome = ?',
            (contador+1, amigo) )
        contadorantigo = contadorantigo + 1
    except:
        cur.execute('''INSERT INTO Twitter (nome, recuperada, amigos)
            VALUES ( ?, 0, 1 )''', ( amigo, ) )
        contadornovo = contadornovo + 1
print('Novas contas=',contadornovo,' revisitada=',contadorantigo)
conn.commit()
~~~~

Depois que o cursor executar a declaração `SELECT`, devemos 
recuperar as linhas. Podemos fazer isso com o comando `for`, 
porém como só vamos recuperar uma linha (`LIMIT 1`), podemos 
usar o método `fetchone()` para buscar a primeira (e única) 
linha que é o resultado da operação `SELECT`. Como `fetchone()` 
retorna a linha como uma *tupla* (mesmo que tenha apenas um campo),
pegaremos o primeiro valor da tupla usando o contador do amigo 
atual na variável `contador`.

Se a recuperação for um sucesso, usamos a declaração SQL `UPDATE`
com a cláusula `WHERE` para adicionar 1 na coluna `amigos` em sua
respectiva linha conta amigo. Note que temos dois espaços reservados
(i.e., pontos de interrogação) em SQL, e o segundo parâmetro `execute()` 
é uma tupla de dois elementos que espera valores para serem substituídos
no SQL no lugar dos pontos de interrogação.

Se o bloco `try` falhar, provavelmente será porque não houve nenhum
registro que correspondeu a cláusula `WHERE name = ?` na declaração SELECT.
Então, no bloco `expect`, usamos a declaração SQL `INSERT` para adicionar um 
`screen_name` amigo na tabela, com uma indicação de que ainda não obtivemos 
um `screen_name` com esse nome, e setamos a contagem desse amigo para zero.

Então, na primeira vez em que o programa for executado e entramos 
com uma conta Twitter, o programa irá rodar como mostra a seguir:

~~~~
Entre com uma conta Twitter, ou digite: drchuck
Recuperando http://api.twitter.com/1.1/friends ...
Novas contas= 20  revisitada= 0
Entre com uma conta Twitter, ou digite sair: sair
~~~~

Como é a primeira vez que rodamos o programa, nosso banco de 
dados está vazio. Criamos então um banco de dados no arquivo 
`spider.sqlite3` e adicionamos, nesse banco, uma tabela chamada 
`Twitter`. Depois, recuperamos alguns amigos e adicionamos 
todos ao nosso banco, já que o mesmo está vazio.

Nesse momento, podemos querer escrever um simples programa que exponha o conteúdo do 
banco de dados para dar uma olhada no que está em nosso arquivo `spider.sqlite3`:

\VerbatimInput{../code3/twdump.py}

Esse programa apenas abre o banco de dados e seleciona todas 
as colunas de todas as linha da tabela `Twitter`, depois percorre
as linhas e imprime em tela cada linha.

Se rodarmos o programa depois da primeira execução do nosso 
programa de rastreamento, sua saída será:

~~~~
('opencontent', 0, 1)
('lhawthorn', 0, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
20 linhas.
~~~~

Nós vemos que há uma linha para cada `screen_name`, que não 
foram recuperados dados para esse `screen_name` e que cada 
um no banco de dados tem um amigo. 

Agora, nosso banco de dados nos mostra os amigos obtidos da 
nossa primeira conta do Twitter (*drchuck*). Nós podemos executar 
o programa novamente e solicitar que o mesmo obtenha os amigos 
da proxima conta ainda "não verificada", simplesmente pressionando 
"enter", como representado a seguir:

~~~~
Entre com uma conta Twitter, ou digite sair: 
Recuperando http://api.twitter.com/1.1/friends ...
Novas contas= 18  revisitada= 2
Entre com uma conta Twitter, ou digite sair: 
Recuperando http://api.twitter.com/1.1/friends ...
Novas contas= 17  revisitada= 3
Entre com uma conta Twitter, ou digite sair: sair
~~~~

Como pressionamos enter (i.e., nós não especificamos uma conta Twitter) 
o seguinte código é executado:

~~~~ {.python}
if ( len(acct) < 1 ) :
    cur.execute('SELECT name FROM Twitter WHERE recuperada= 0 LIMIT 1')
    try:
        acct = cur.fetchone()[0]
    except:
        print('Nenhuma conta não visitada encontrada')
        continue
~~~~

Nós usamos a declaração SQL `SELECT` para recuperar o nome do primeiro 
usuário (`LIMIT 1`) que ainda tem o valor "nós recuperamos esse usuário" 
igual a zero. Nós, também, usamos o padrão `fetchone()[0]` dentro do 
bloco try/except ou para extrair `screen_name` dos dados recuperados ou 
para imprimir em tela uma mensagem de erro e fazer laço novamente.

Se conseguirmos recuperar um `screen_name` ainda não processado, 
recuperamos os dados como mostra:


~~~~ {.python}
url=twurl.augment(TWITTER_URL,{'screen_name': acct,'count': '20'})
print('Recuperando', url)
connection = urllib.urlopen(url)
data = connection.read()
js = json.loads(data)

cur.execute('UPDATE Twitter SET recuperada=1 WHERE nome = ?',(acct, ))
~~~~

Depois que recuperamos os dados, nós usamos a declaração `UPDATE` 
para setar a coluna `recuperada` para 1, para indicar que nós 
completamos a recuperação dos amigos dessa conta. Isso evita que 
recuperemos a mesma informação várias vezes, fazendo que sempre 
possamos progredir na lista de amigos do Twitter.

Se rodarmos o programa e pressionarmos "enter" duas vezes para recuperar 
os próximos amigos não visitados do amigo, depois rodarmos o programa expositor, 
ele irá nos mostrar a seguinte saída:

~~~~
('opencontent', 1, 1)
('lhawthorn', 1, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
('cnxorg', 0, 2)
('knoop', 0, 1)
('kthanos', 0, 2)
('LectureTools', 0, 1)
...
55 linhas.
~~~~

Podemos ver que armazenamos de forma correta que visitamos 
`lhawthorn` e `opencontent`. Também verificamos que as contas 
`cnxorg` e `kthanos` já têm dois seguidores. Como agora recuperamos
os amigos de três pessoas (`drchuck`, `opencontent`, e `lhawthorn`), 
nossa tabela tem 55 linhas de amigos recuperados.

Cada vez que rodarmos o programa e pressionarmos a tecla "enter", nós 
iremos pegar a próxima conta de um amigo "não visitado" (e.g., a próxima
conta será `steve_coppin`), recuperar seus amigos, marcar eles como 
recuperados e assim, para cada amigo de `steve_cooping`, ou iremos adicionar
no final do nosso banco de dados, ou iremos atualizar a contagem de amigos 
se esse amigo já existir no banco de dados.

Como os dados do programa estão armazenados no disco em um banco de 
dados, uma atividade de rastreamento pode ser suspensa e retomada 
quantas vezes você queira sem que haja perca de dados. 


Modelagem Básica de Dados
-------------------
O poder real de um banco de dados relacional é quando criamos 
múltiplas tabelas e criamos links entre essas tabelas. O ato de decidir
quando dividir sua tabela em várias outras e estabelecer relacionamentos
entre as tabelas é chamado de *modelagem de dados*. O documento de 
design que mostra essas tabelas e seus relacionamentos é chamado 
de *modelo de dados*.

Modelar dados é uma habilidade relativamente sofisticada e nós 
iremos apenas introduzir os mais básicos conceitos de modelagem de 
dados relacionados nesta sessão. Para mais detalhes sobre modelagem 
de dados, você pode acessar:

<http://en.wikipedia.org/wiki/Relational_model>

Vamos dizer que em nossa aplicação de rastreamento ao Twitter, em vez 
de apenas contar a quantidade de amigos de uma determinada pessoa, 
também iremos manter uma lista de todos relacionamentos para que 
possamos achar uma lista de todas a pessoas que estão seguindo 
esta pessoa em particular.

Como todo mundo provavelmente tem muitas contas que os seguem, 
não podemos simplesmente iremos adicionar uma única coluna em nossa 
tabela `Twitter`. Então, criaremos uma nova tabela que irá permanecer 
rastreando pares de amigos. O trecho de código a seguir é uma 
simples forma de criar essa nova tabela.

~~~~ {.sql}
CREATE TABLE Parceiros (de_amigo TEXT, para_amigo TEXT)
~~~~

Toda vez que nós encontrarmos uma nova pessoa que 
`drchuck` está seguindo, iremos inserir uma linha da forma:

~~~~ {.sql}
INSERT INTO Parceiros (from_friend,to_friend) VALUES ('drchuck', 'lhawthorn')
~~~~

Como estamos processando as informações dos 20 amigos do "feed" 
do `drchuck`, iremos inserir 20 registros com "drchuck" como parâmetro, 
resultando no duplicamento de strings várias vezes no nosso banco de dados.

A duplicação de uma string viola uma das boas práticas de *normalização 
de banco de dados*, que basicamente afirma que nunca devemos colocar uma 
string como mesmo valor no nosso banco de dados mais de uma vez. Se 
precisarmos do dado mais que uma vez, criamos uma *chave* numérica e 
referenciamos tal string por meio dessa chave.

Em termos práticos, uma string toma muito mais espaço que um inteiro 
no disco e na memória do computador, e toma mais tempo de processamento para 
comparar e ordenar. Se temos apenas poucas centenas de entradas, o armazenamento 
e o tempo de processamento dificilmente irá importar. Porém, se tivermos um milhão
de pessoas no nosso banco de dados e uma possibilidade de 100 milhões de amigos 
linkados, será importante seu programa ser capaz de escanear seus dados da maneira
mais rápida possível.

Iremos armazenar as contas do Twitter em uma tabela chamada `Pessoas` em vez da tabela 
`Twitter` usada no exemplo anterior. A tabela `Pessoas` tem uma coluna a mais para 
adicionar uma chave numérica associada com a linha dessa conta Twitter. SQLite possui 
um recurso que automaticamente adiciona uma chave para cada linha inserida na tabela 
usando um tipo especial de coluna (`INTEGER PRIMARY KEY`)

Podemos criar a tabela `Pessoas` com uma coluna adicional `id` como segue:

~~~~ {.sql}
CREATE TABLE Pessoas
    (id INTEGER PRIMARY KEY, nome TEXT UNIQUE, recuperada INTEGER)
~~~~

Note que não estamos mais mantendo uma conta amigo em cada linha da tabela `Pessoas`. 
Quando selecionamos `INTEGER PRIMARY KEY` como um tipo da nossa coluna `id`, nós 
indicamos que queremos que o SQLite gerencie a coluna e atribua, automaticamente, 
uma chave numérica única para cada linha que inserirmos na nossa tabela. Também 
podemos adicionar a palavra chave `UNIQUE` para indicar que não iremos permitir que o 
SQLite insira duas colunas como o mesmo valor no campo `nome`.

Agora, em vez de criar a tabela `Parceiros`, iremos criar uma tabela 
chamada `Segue` com duas colunas de inteiros: `de_id` e `para_id` e uma 
restrição na tabela para que a *combinação* de `de_id` e `para_id` seja única nessa tabela
(i.e., não podemos inserir linhas duplicadas) em nosso banco de dados.


~~~~ {.sql}
CREATE TABLE Segue
    (de_id INTEGER, para_id INTEGER, UNIQUE(de_id, para_id) )
~~~~

Quando adicionamos a restrição `UNIQUE` em nossas tabelas, estamos impondo certas 
regras para o nosso banco de dados quando tentarmos inserir novos registros. 
Estamos criando essas regras como convenção nos nossos programas, como veremos 
em seguida. As regras tanto nos impedem de cometer erros como tornam mais fácil escrever 
parte do nosso código.

Na essência, quando criamos a tabela `Segue`, estamos modelando uma "relacionamento" 
onde uma pessoa "segue" alguma outra e representando isso com um par de números 
indicando que a: (a) as pessoas estão conectadas e (b) a direção do relacionamento.

![Relações Entre Tabelas](height=3.5in@figs2/twitter)


Programando com múltiplas tabelas
--------------------------------

Agora iremos refazer nosso programa de rastreamento do Twitter 
usando duas tabelas, as chaves primárias, e as referências a essas chaves
como descrito acima. Aqui está o código da nova versão do nosso programa:

\VerbatimInput{../code3/twfriends.py}

Esse programa está começando a ficar um pouco complicado, mas irá ilustrar
o passo a passo que nós realmente precisaremos usar quando estamos usando chaves
inteiras para linkar tabelas. Os passos básicos são:

1.  Criar tabelas com chaves primárias e restrições.

2.  Quando temos uma chave lógica para uma pessoa (i.e, nome da conta) e precisamos 
    do valor `id` dessa, dependendo se essa pessoa já está ou não na tabela 
    `Pessoas`, teremos que: (1) Procurar essa pessoa na tabela `Pessoas` e recuperar
    o valor do `id` daquela ou (2) adicionar essa pessoa na tabela `Pessoas` e 
    pegar o valor do `id` dessa nova linha adicionada. 

3.  Inserir a linha que retorna o relacionamento dos "seguidores"

Nós iremos abordar cada um desses passos por vez.

### Restrições em tabelas do banco de dados

A medida que planejamos a estrutura de nossa tabela, podemos dizer ao sistema de banco de dados que gostaríamos que ele nos impusesse algumas regras. Essas regras evitam que possamos cometer erros e que dados incorretos sejam introduzidos nas tabelas. Quando criamos nossas tabelas:

~~~~ {.python}
cur.execute('''CREATE TABLE IF NOT EXISTS Pessoas
    (id INTEGER PRIMARY KEY, nome TEXT UNIQUE, recuperado INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Segue
    (de_id INTEGER, para_id INTEGER, UNIQUE(de_id, para_id))''')
~~~~


Indicamos que a coluna `nome` na tabela `Pessoas` precisa ser `UNIQUE`. Nós também indicamos que a combinação dos dois números em cada linha da tabela `Segue` deve ser única. Essas restrições nos impedem de cometer o erro de adicionar a mesma relação mais de uma vez. 

Podemos nos aproveitar dessas restrições no código a seguir:

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO Pessoas (nome, recuperado)
    VALUES ( ?, 0)''', ( amigo, ) )
~~~~

Podemos adicionar a cláusula `OR IGNORE` à declaração `INSERT` para indicar que caso este `INSERT` em particular venha a causar uma violação da regra “`nome` deve ser único“, o sistema de banco de dados está autorizado a ignorar o `INSERT`. Assim, estamos usando as restrições do banco de dados como um filtro de segurança, garantindo que não iremos fazer algo errado inadvertidamente. 

De forma similar, o código a seguir assegura que não adicionaremos a mesma relação `Segue` mais de uma vez.  

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO Segue
    (from_id, to_id) VALUES (?, ?)''', (id, amigo_id) )
~~~~

Novamente, apenas dizemos ao banco de dados para ignorar a tentativa `INSERT` caso ela viole a restrição de singularidade que especificamos para as linhas de `Segue`. 


### Recuperar e/ou inserir um registro

Quando requisitamos ao usuário uma conta do Twitter, se a conta existir, devemos procurar seu valor `id`. Se a conta não existir na tabela `Pessoas`, devemos inserir um registro e guardar o valor `id` da linha inserida.

Esse é um padrão muito comum e feito duas vezes no programa abaixo. O código mostra como procuramos pelo `id` da conta de um amigo, quando tivermos extraído o `screen_name` do `usuário` presente no Twitter JSON recuperado. 

Já que ao longo do tempo há uma maior chance da conta constar no banco de dados, primeiro verificamos se o registro em `Pessoas` existe, usando a declaração `SELECT`. 

Se tudo ocorrer bem^[Em geral, quando a frase começar com “se tudo ocorrer bem”, você perceberá que o código precisa de um bloco try/except.] dentro da seção `try`, devemos recuperar o registro usando `fetchone()` e então retirar o primeiro (e apenas o primeiro) elemento da tupla obtida e armazená-la em `amigo_id`.

Caso `SELECT` resulte em falha, o código `fetchone()[0]` irá falhar e o controlador executará a seção `except`.

~~~~ {.python}
    amigo = u['screen_name']
    cur.execute('SELECT id FROM Pessoas WHERE nome = ? LIMIT 1',
        (amigo, ) )
    try:
        amigo_id = cur.fetchone()[0]
        contadorantigo = contadorantigo + 1
    except:
        cur.execute('''INSERT OR IGNORE INTO Pessoas (nome, recuperado)
            VALUES ( ?, 0)''', ( amigo, ) )
        conn.commit()
        if cur.rowcount != 1 :
            print('Error inserting account:', amigo)
            continue
        amigo_id = cur.lastrowid
        contadornovo = contadornovo + 1
~~~~

Caso o código `except` seja executado, apenas significa que a linha não foi encontrada e, portanto, deve ser inserida. Usamos `INSERT OR IGNORE` para evitar erros e então chamar `commit()` para forçar o banco de dados a ser atualizado. Depois da escrita ter sido feita, podemos verificar o `cur_rowcount` para ver quantas linhas foram afetadas. Já que estamos tentando inserir uma única linha, se o número de linhas afetados for diferente de 1, houve um erro. 

No entanto, se o `INSERT` for bem sucedido, `cur_lastrowid` pode ser avaliado para encontrar o valor na coluna `id`, atribuído pelo banco de dados, da nova linha.

### Storing the friend relationship

Uma vez que sabemos o valor chave para tanto o usuário do Twitter quanto seu amigo, no JSON, basta inserirmos os dois números na tabela `Segue` com o código abaixo:

~~~~ {.python}
cur.execute('INSERT OR IGNORE INTO Segue (de_id, para_id) VALUES (?, ?)',
    (id, amigo_id) )
~~~~

Note que encarregamos o banco de dados de nos prevenir de inserir duas vezes uma relação. Isto se dá ao criarmos uma tabela com a restrição de singularidade e então adicionando `OR IGNORE` à declaração `INSERT`.

Aqui está um exemplo da execução desse programa: 

~~~~
Enter a Twitter account, or quit:
No unretrieved Twitter accounts found
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
~~~~

Começamos com a conta `drchuck` e então deixamos o programa automaticamente selecionar as duas contas a serem obtidas e adicionadas ao nosso banco de dados.

Abaixo estão as primeiras linhas para as tabelas `Pessoas` e `Segue`, após a execução ser finalizada: 

~~~~
Pessoas:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Segue:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
~~~~

Você pode ver os campos `id`, `nome` e `visitado` na tabela `Pessoas`, bem como os números em ambas as pontas da relação na tabela `Segue`. Na tabela `Pessoas`, vemos que as três primeiras pessoas foram visitadas e suas informações foram obtidas. Os dados na tabela `Segue` indicam que `drchuck` (usuário 1) é amigo de todas as pessoas nas primeiras 5 linhas. Isso faz sentido já que o primeiro conjunto de informações recuperado e armazenado foi referente aos amigos de `drchuck`. Se desejasse imprimir mais linhas da tabela `Segue`, também veria os amigos dos usuários 2 e 3.


Três tipos de chaves
-------------------

Agora que começamos construindo um modelo de dados colocando nossos dados dentro
várias tabelas vinculadas e vinculando as linhas nessas tabelas usando
*chaves*, nós precisamos examinar algumas terminologias em torno das chaves.
Geralmente existem três tipos de chaves usadas em um modelo de banco de dados.

-   Uma *Chave lógica* é uma chave que no "mundo real" pode ser
    usado para procurar uma linha. No nosso exemplo de modelo de dados, o
    campo `nome` é uma chave lógica. É o nome de tela para
    o usuário e nós de fato procuramos linhas de um usuários várias vezes no
    programa usando o campo `nome`. Você vai notar frequentemente que
    isso faz sentido para adicionar uma restrição `UNIQUE` para uma chave lógica.
    Como a chave lógica é como procuramos uma linha do "mundo externo", 
    faz pouco sentido permitir várias linhas com o mesmo
    valor na tabela.

-   Uma *chave primária* é geralmente um número que é atribuído
    automaticamente pelo banco de dados. Geralmente não tem significado fora
    do programa e é usado somente para para vincular linhas de diferentes tabelas
    juntas. Quando queremos procurar uma linha em uma tabela, geralmente
    pesquisar pela linha usando a chave primária é a maneira mais rápida para
    encontrar uma linha. Como as chaves primárias são números inteiros, elas ocupam
    muito pouco armazenamento e podem ser comparadas ou classificadas muito rapidamente. No
    nosso modelo de dados, o campo `id` é um exemplo de uma chave primária.
    

-   Uma *chave estrangeira* é geralmente um número que aponta para
    uma chave primária de uma linha associada em uma tabela diferente. Como
    exemplo de uma chave estrangeira em nosso modelo de dados é o `de_id`.

Estamos usando uma convenção de nomenclatura de sempre chamar o campo de chave primária 
nome `identidade` e aparecendo o sufixo `_id` para qualquer campo nome
que é uma chave estrangeira.

Usando JOIN para recuperar dados
---------------------------

Agora que temos seguido as regras de normalização de banco de dados e temos
dados separados dentro de duas tabelas, interligados usando chaves primárias e
estrangeiras, precisamos estar prontos para construir uma `SELECT` que
remonta os dados nas tabelas.

SQL usa a cláusula `JOIN` para reconectar essas tabelas. Na
cláusula `JOIN` você especifica os campos que são usados para
reconectar as linhas entre as tabelas.

A seguir está um exemplo de uma `SELECT` com uma cláusula
`JOIN`:

~~~~ {.sql}
SELECT * FROM Seguidores JOIN Pessoas
    ON Seguidores.de_id = Pessoas.id WHERE Pessoas.id = 1
~~~~

A cláusula `JOIN` indica que os campos que estamos selecionando
cruze as tabelas `Seguidores` e `Pessoas`. A cláusula
`ON` indicada como as duas tabelas devem ser unidas:
Pegue as linhas de `Seguidores` e acrescente a linha de
`Pessoas` onde o campo `de_id` em `Seguidores` é
o mesmo valor `id` na tabela `Pessoas`.

![Conectando Tabelas Usando JOIN](height=3.5in@figs2/join)

O resultado de JOIN é criar "metalinhas" extra-longas as quais possuem
os campos de `Pessoas` e os campos correspondentes de
`Seguidores`. Onde existem mais que um correspondente entre o campo
`id` de `Pessoas` e o `de_id` de
`Pessoas`, quando JOIN cria uma metalinha para *cada*
par de linhas correspondentes, duplicaando dados conforme necessário.

A código a seguir demonstra dados que teremos no banco de dados
após o programa multi-tables Twitter spider (acima) ser
executado várias vezes.

\VerbatimInput{../code3/twjoin.py}

Nesse programa, nós primeiramente expomos as `Pessoa` e os
`Seguidores` e daí expomos um subconjunto do dados nas tabelas
unidas.

Aqui está a saída do programa:

~~~~
python twjoin.py
Pessoas:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 linhas.
Seguidores:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 linhas.
Conexões para id=2:
(2, 1, 1, 'drchuck', 1)
(2, 28, 28, 'cnxorg', 0)
(2, 30, 30, 'kthanos', 0)
(2, 102, 102, 'SomethingGirl', 0)
(2, 103, 103, 'ja_Pac', 0)
20 linhas.
~~~~

Você vê as colunas da tabela `Pessoa` e
`Seguidores` e o último conjunto de linhas é o resultado de
 `SELECT` com a cláusula `JOIN`.

Na última seleção, estamos olhando para contas que são amigas de
"opencontent" (i.e., `Pessoa.id=2`).

Em cada uma das "metalinhas" na última seleção, a primeira das duas colunas são
da tabela `Seguidores` seguido por três colunas através
de cinco da tabela `Pessoas`. Você pode também ver que a segunda coluna
(`Seguidores.to_id`) corresponde a terceira coluna
(`Pessoas.id`) em cada das "metalinhas" associadas.

Sumário
-------

Esse capítulo englobou muito assunto para te dar uma visão geral do básico
sobre como usar base de dados em Python. É mais complicado escrever o 
código para usar a base de dados para guardar os dados que dicionários em 
Python ou arquivos simples, então existe pouca razão para usar banco de
dados a não ser que sua aplicação realmente precise das capacidades de um banco
de dados. As situações que um banco de dados pode ser útil são: (1) quando sua
aplicação precisa fazer pequenas atualizações aleatórias em um grande conjunto de
dados, (2) quando seus dados são tão grandes que não se encaixam num dicionário
e você precisa analisar as informações repetidamente, ou (3) quando você tem
um processo de longa duração que você é capaz de parar e reiniciar e manter as 
informações de uma inicialização para a outra.

Você pode construir uma simples base de dados com uma única tabela para 
satisfazer as necessidades da aplicação, mas várias aplicações exigirão várias
tabelas e conexões/relações entre linhas em diferentes tabelas. Quando começar 
a fazer conexões entre tabelas, é importante fazer um projeto mais pensado e 
seguir as regras de normalização de base de dados para fazer melhor uso das suas
capacidades. Visto que a principal motivação para usar um banco de dados é que 
há uma grande quantidade de dados para se lidar, é importante categorizar seus 
dados de maneira eficiente para que seu programa funcione o mais rápido possível.

Depurando
---------

Um padrão comum quando você está desenvolvendo um programa Python para
conexão de uma base de dados SQLite será a de iniciar o programa e 
conferir os resultados usando o navegador de banco de dados pro SQLite.
O navegador te permite verificar rapidamente se o programa está 
funcionando corretamente.

Você precisa ter cuidado pois SQLite se certifica de evitar dois programas
de modificarem o mesmo dado ao mesmo tempo. Por exemplo, se você abrir o
banco de dados no navegador e modificá-lo, porém não pressionar o botão 
"salvar" ainda, o navegador "trava" o arquivo do banco de dados e evita 
qualquer outro programa de acessar o arquivo. Em particular, seu programa
Python não será capaz de acessar o arquivo se ele estiver bloqueado.

Então a solução é ter certeza de fechar o navegador do banco de dados
ou usar o menu *Arquivo* para fechar o banco de dados no navegador antes 
de tentar acessar a base de dados pelo Python para evitar o problema do
código falhar por causa do banco de dados estar bloqueado.

Glossário
--------

atributo
:   Um dos valores da tupla. Mais comumente chamado de "coluna" ou 
    "campo".
\index{attribute}

restrição
:   Quando chamamos o banco de dados para import uma regra num campo ou 
    numa linha numa tabela. Uma regra comum é restringir que não possa haver valores duplicados num campo em particular (i.e., todos os valores devem ser únicos).
\index{constraint}

cursor
:   O cursor te permite executar comandos SQL no banco de dados e 
    recuperar dados dele. O cursor é similar ao socket ou 
    ao identificaor de arquivo das conexões de internet e arquivos,
    respectivamente.
\index{cursor}

navegador de banco de dados
:   *Software* que te permite se conectar diretamente com o banco de dados
    para manipulá-lo diretamente sem escrever um programa.
\index{database browser}

chave externa
:   Uma chave numérica que aponta para a primeira chave de uma linha de
    outra tabela. Chaves externas estabelecem relações entre linhas
    armazenadas em tabelas diferentes.
\index{foreign key}

índice
:   Dado adicional que o *software* do banco de dados conserva como linhas
    e adiciona na tabela pra facilitar acelerar a visualização dos dados.
\index{index}
\index{}

chave lógica
:   A chave que o "mundo externo" usa para visualizar uma linha em 
    particular. Por exemplo em uma tabela de contas de usuários, o email
    de uma pessoa poderia ser um ótimo candidato a ser uma chave lógica
    para os dados do usuário.
    \index{logical key}

normalização
:   modelar os dados para que não haja réplicas. Guarda-se cada item dos
    dados em um local no banco de dados e se faz referência dele em outro
    lugar utilizando uma chave externa.
\index{normalization}
\index{database normalization}

chave primária
:   Uma chave numérica atribuída a cada linha é utilizada para se 
    referenciar uma linha na tabela por meio de outra tabela. Usualmente 
    os bancos de dados são configurados para atribuir automaticamente 
    chaves primárias assim que linhas são inseridas.
\index{primary key}

relação
:   Uma área no banco de dados que contém tuplas e atributos. Mais 
    comumente chamada como "tabela".
\index{relation}

tupla
:   Uma entrada simples numa tabela do banco de dados que é um conjunto 
    de atributos. Mais comumente chamada como "linha".
\index{tuple}

